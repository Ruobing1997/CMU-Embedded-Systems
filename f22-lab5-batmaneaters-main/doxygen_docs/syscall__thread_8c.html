<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>14642 Lab3: kernel/src/syscall_thread.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">14642 Lab3
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part --><!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_dc43877d82dd332f9fb2071fcca799d6.html">kernel</a></li><li class="navelem"><a class="el" href="dir_3dd30a497388ee684638f120a124721c.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">syscall_thread.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>thread syscall implementation for lab 4  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;<a class="el" href="arm_8h_source.html">arm.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="mpu_8h_source.html">mpu.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="printk_8h_source.html">printk.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="syscall_8h_source.html">syscall.h</a>&gt;</code><br />
<code>#include &lt;syscall_mutex.h&gt;</code><br />
<code>#include &lt;<a class="el" href="syscall__thread_8h_source.html">syscall_thread.h</a>&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;<a class="el" href="svc__num_8h_source.html">svc_num.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="timer_8h_source.html">timer.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for syscall_thread.c:</div>
<div class="dyncontent">
<div class="center"><img src="syscall__thread_8c__incl.png" border="0" usemap="#kernel_2src_2syscall__thread_8c" alt=""/></div>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memItemLeft" align="right" valign="top"><a id="a3c88edc8d48ce7172e288f14dd6a06d6"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3c88edc8d48ce7172e288f14dd6a06d6">XPSR_INIT</a>&#160;&#160;&#160;0x1000000</td></tr>
<tr class="memdesc:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial XPSR value, all 0s except thumb bit. <br /></td></tr>
<tr class="separator:a3c88edc8d48ce7172e288f14dd6a06d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memItemLeft" align="right" valign="top"><a id="a8a6ea3d12a6db3f3a0b8afcb52881c2a"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8a6ea3d12a6db3f3a0b8afcb52881c2a">LR_RETURN_TO_USER_PSP</a>&#160;&#160;&#160;0xFFFFFFFD</td></tr>
<tr class="memdesc:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return code to return to user mode with user stack. <br /></td></tr>
<tr class="separator:a8a6ea3d12a6db3f3a0b8afcb52881c2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d518b14d40f2fdd1d08f73f36e57c56"><td class="memItemLeft" align="right" valign="top"><a id="a2d518b14d40f2fdd1d08f73f36e57c56"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2d518b14d40f2fdd1d08f73f36e57c56">STACK_SPACE_LIMIT</a>&#160;&#160;&#160;32768</td></tr>
<tr class="memdesc:a2d518b14d40f2fdd1d08f73f36e57c56"><td class="mdescLeft">&#160;</td><td class="mdescRight">define stack space limit. <br /></td></tr>
<tr class="separator:a2d518b14d40f2fdd1d08f73f36e57c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3af58f189784d7cbf90a5f95d03c08df"><td class="memItemLeft" align="right" valign="top"><a id="a3af58f189784d7cbf90a5f95d03c08df"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3af58f189784d7cbf90a5f95d03c08df">RUNNING_STATUS</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a3af58f189784d7cbf90a5f95d03c08df"><td class="mdescLeft">&#160;</td><td class="mdescRight">define running status <br /></td></tr>
<tr class="separator:a3af58f189784d7cbf90a5f95d03c08df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad042c618aaadac0e43ce7539c5c4f792"><td class="memItemLeft" align="right" valign="top"><a id="ad042c618aaadac0e43ce7539c5c4f792"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ad042c618aaadac0e43ce7539c5c4f792">WAITING_STATUS</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:ad042c618aaadac0e43ce7539c5c4f792"><td class="mdescLeft">&#160;</td><td class="mdescRight">define waiting status <br /></td></tr>
<tr class="separator:ad042c618aaadac0e43ce7539c5c4f792"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf211be8b21cbb632074a3d4a52bf145"><td class="memItemLeft" align="right" valign="top"><a id="acf211be8b21cbb632074a3d4a52bf145"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#acf211be8b21cbb632074a3d4a52bf145">RUNNABLE_STATUS</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:acf211be8b21cbb632074a3d4a52bf145"><td class="mdescLeft">&#160;</td><td class="mdescRight">define runnable status <br /></td></tr>
<tr class="separator:acf211be8b21cbb632074a3d4a52bf145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1ba4ac894a4fc2a8f6e79169d85448"><td class="memItemLeft" align="right" valign="top"><a id="aec1ba4ac894a4fc2a8f6e79169d85448"></a>
#<a class="el" href="structdefine.html">define</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aec1ba4ac894a4fc2a8f6e79169d85448">UNINITIALIZE_STATUS</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:aec1ba4ac894a4fc2a8f6e79169d85448"><td class="mdescLeft">&#160;</td><td class="mdescRight">define uninitialized status for killed thread <br /></td></tr>
<tr class="separator:aec1ba4ac894a4fc2a8f6e79169d85448"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2161e413aa57c884e52460240ffabe62"><td class="memItemLeft" align="right" valign="top"><a id="a2161e413aa57c884e52460240ffabe62"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2161e413aa57c884e52460240ffabe62">thread_kill</a> ()</td></tr>
<tr class="memdesc:a2161e413aa57c884e52460240ffabe62"><td class="mdescLeft">&#160;</td><td class="mdescRight">define extern function to use thread_kill <br /></td></tr>
<tr class="separator:a2161e413aa57c884e52460240ffabe62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84de83d8cbea30290aab3c7eee772049"><td class="memItemLeft" align="right" valign="top"><a id="a84de83d8cbea30290aab3c7eee772049"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a84de83d8cbea30290aab3c7eee772049">default_idle</a> ()</td></tr>
<tr class="memdesc:a84de83d8cbea30290aab3c7eee772049"><td class="mdescLeft">&#160;</td><td class="mdescRight">define extern idle function to use <br /></td></tr>
<tr class="separator:a84de83d8cbea30290aab3c7eee772049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc96a6564aa346ba124293a6604a0427"><td class="memItemLeft" align="right" valign="top"><a id="abc96a6564aa346ba124293a6604a0427"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#abc96a6564aa346ba124293a6604a0427">systick_c_handler</a> ()</td></tr>
<tr class="memdesc:abc96a6564aa346ba124293a6604a0427"><td class="mdescLeft">&#160;</td><td class="mdescRight">systick c handler function (1) increase global time everytime systick is called (2) update RMS status (3) call pendsv to start context switch <br /></td></tr>
<tr class="separator:abc96a6564aa346ba124293a6604a0427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3804439769e7e553283b916886c5b67d"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3804439769e7e553283b916886c5b67d">pendsv_c_handler</a> (void *msp)</td></tr>
<tr class="memdesc:a3804439769e7e553283b916886c5b67d"><td class="mdescLeft">&#160;</td><td class="mdescRight">pendsv c handler function  <a href="syscall__thread_8c.html#a3804439769e7e553283b916886c5b67d">More...</a><br /></td></tr>
<tr class="separator:a3804439769e7e553283b916886c5b67d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b452cd176c28323372e441a3aac0631"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3b452cd176c28323372e441a3aac0631">sys_thread_init</a> (uint32_t max_threads, uint32_t stack_size, void *idle_fn, <a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a> memory_protection, uint32_t max_mutexes)</td></tr>
<tr class="memdesc:a3b452cd176c28323372e441a3aac0631"><td class="mdescLeft">&#160;</td><td class="mdescRight">init thread function  <a href="syscall__thread_8c.html#a3b452cd176c28323372e441a3aac0631">More...</a><br /></td></tr>
<tr class="separator:a3b452cd176c28323372e441a3aac0631"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1cf2fc01bb33b62a5d3a1acbe851e8"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a9b1cf2fc01bb33b62a5d3a1acbe851e8">calculate_utilization</a> (uint32_t C, uint32_t T)</td></tr>
<tr class="memdesc:a9b1cf2fc01bb33b62a5d3a1acbe851e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculate utilization for UB test  <a href="syscall__thread_8c.html#a9b1cf2fc01bb33b62a5d3a1acbe851e8">More...</a><br /></td></tr>
<tr class="separator:a9b1cf2fc01bb33b62a5d3a1acbe851e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54104218aaaba481bd42968a6045691"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac54104218aaaba481bd42968a6045691">sys_thread_create</a> (void *fn, uint32_t prio, uint32_t C, uint32_t T, void *vargp)</td></tr>
<tr class="memdesc:ac54104218aaaba481bd42968a6045691"><td class="mdescLeft">&#160;</td><td class="mdescRight">create thread using provided parameters  <a href="syscall__thread_8c.html#ac54104218aaaba481bd42968a6045691">More...</a><br /></td></tr>
<tr class="separator:ac54104218aaaba481bd42968a6045691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0726d2166701a485c555e6b7f7af3b60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">sys_scheduler_start</a> (uint32_t frequency)</td></tr>
<tr class="memdesc:a0726d2166701a485c555e6b7f7af3b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for starting scheduler, start systick and call pendsv interrupt  <a href="syscall__thread_8c.html#a0726d2166701a485c555e6b7f7af3b60">More...</a><br /></td></tr>
<tr class="separator:a0726d2166701a485c555e6b7f7af3b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2cee94a562548fe28ea76bd6ceb738c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa2cee94a562548fe28ea76bd6ceb738c">round_robin_scheduler</a> ()</td></tr>
<tr class="memdesc:aa2cee94a562548fe28ea76bd6ceb738c"><td class="mdescLeft">&#160;</td><td class="mdescRight">round robin scheduler to find next thread to be scheduled  <a href="syscall__thread_8c.html#aa2cee94a562548fe28ea76bd6ceb738c">More...</a><br /></td></tr>
<tr class="separator:aa2cee94a562548fe28ea76bd6ceb738c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24f0f7bfbc5f3ebc4100c56a6f96490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ae24f0f7bfbc5f3ebc4100c56a6f96490">Systick_RMS_scheduler</a> ()</td></tr>
<tr class="memdesc:ae24f0f7bfbc5f3ebc4100c56a6f96490"><td class="mdescLeft">&#160;</td><td class="mdescRight">update RMS status for every systick  <a href="syscall__thread_8c.html#ae24f0f7bfbc5f3ebc4100c56a6f96490">More...</a><br /></td></tr>
<tr class="separator:ae24f0f7bfbc5f3ebc4100c56a6f96490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3595cc3f898a5bedef3510bf9dd8f6f1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a3595cc3f898a5bedef3510bf9dd8f6f1">RMS_Scheduler_Highest</a> ()</td></tr>
<tr class="memdesc:a3595cc3f898a5bedef3510bf9dd8f6f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMS scheduler to find next thread to be scheduled.  <a href="syscall__thread_8c.html#a3595cc3f898a5bedef3510bf9dd8f6f1">More...</a><br /></td></tr>
<tr class="separator:a3595cc3f898a5bedef3510bf9dd8f6f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f015c606e6bf18b8a9311f70bb3dbc8"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0f015c606e6bf18b8a9311f70bb3dbc8">schedule_next</a> ()</td></tr>
<tr class="memdesc:a0f015c606e6bf18b8a9311f70bb3dbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">call corresponding scheduler function to find scheduled thread  <a href="syscall__thread_8c.html#a0f015c606e6bf18b8a9311f70bb3dbc8">More...</a><br /></td></tr>
<tr class="separator:a0f015c606e6bf18b8a9311f70bb3dbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">sys_get_priority</a> ()</td></tr>
<tr class="memdesc:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="mdescLeft">&#160;</td><td class="mdescRight">get thread priority  <a href="syscall__thread_8c.html#a8b4f86fe10ac2c90ce8158872aac7ce2">More...</a><br /></td></tr>
<tr class="separator:a8b4f86fe10ac2c90ce8158872aac7ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a341334c885696457b6f66bb8acda5b22"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">sys_get_time</a> ()</td></tr>
<tr class="memdesc:a341334c885696457b6f66bb8acda5b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">get global time, update time field in every systick  <a href="syscall__thread_8c.html#a341334c885696457b6f66bb8acda5b22">More...</a><br /></td></tr>
<tr class="separator:a341334c885696457b6f66bb8acda5b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8933e910725546aa9e052369db9cf81"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">sys_thread_time</a> ()</td></tr>
<tr class="memdesc:aa8933e910725546aa9e052369db9cf81"><td class="mdescLeft">&#160;</td><td class="mdescRight">get thread time  <a href="syscall__thread_8c.html#aa8933e910725546aa9e052369db9cf81">More...</a><br /></td></tr>
<tr class="separator:aa8933e910725546aa9e052369db9cf81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601e5d8e922ccdec535527e8d8724d78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">sys_thread_kill</a> ()</td></tr>
<tr class="memdesc:a601e5d8e922ccdec535527e8d8724d78"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread kill function (1) kill current thread, update status (2) update utilization field for thread reuse  <a href="syscall__thread_8c.html#a601e5d8e922ccdec535527e8d8724d78">More...</a><br /></td></tr>
<tr class="separator:a601e5d8e922ccdec535527e8d8724d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3a3fb472158a93e59df836b9935b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">sys_wait_until_next_period</a> ()</td></tr>
<tr class="memdesc:a2a3a3fb472158a93e59df836b9935b54"><td class="mdescLeft">&#160;</td><td class="mdescRight">syscall for wait until next period function (1) update current thread's status to waiting status (2) call pendsv to do context switch  <a href="syscall__thread_8c.html#a2a3a3fb472158a93e59df836b9935b54">More...</a><br /></td></tr>
<tr class="separator:a2a3a3fb472158a93e59df836b9935b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12d3058e8c4464d614c9506562710e91"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">sys_mutex_init</a> (uint32_t max_prio)</td></tr>
<tr class="memdesc:a12d3058e8c4464d614c9506562710e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for initializing mutex  <a href="syscall__thread_8c.html#a12d3058e8c4464d614c9506562710e91">More...</a><br /></td></tr>
<tr class="separator:a12d3058e8c4464d614c9506562710e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7723d9d93291270e4ca71289e8a3c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a9b7723d9d93291270e4ca71289e8a3c4">mutex_check_block</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:a9b7723d9d93291270e4ca71289e8a3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if mutex is locked by specific thread  <a href="syscall__thread_8c.html#a9b7723d9d93291270e4ca71289e8a3c4">More...</a><br /></td></tr>
<tr class="separator:a9b7723d9d93291270e4ca71289e8a3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4de7534d78e9925e4465a8de5fb7dfb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ad4de7534d78e9925e4465a8de5fb7dfb">mutex_check_unblock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:ad4de7534d78e9925e4465a8de5fb7dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">uunblock mutex, check next thread for this mutex  <a href="syscall__thread_8c.html#ad4de7534d78e9925e4465a8de5fb7dfb">More...</a><br /></td></tr>
<tr class="separator:ad4de7534d78e9925e4465a8de5fb7dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2a7192638c40706831495cb42ee4e96"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac2a7192638c40706831495cb42ee4e96">check_handle</a> (uint32_t mutex_index)</td></tr>
<tr class="memdesc:ac2a7192638c40706831495cb42ee4e96"><td class="mdescLeft">&#160;</td><td class="mdescRight">check if mutex exists  <a href="syscall__thread_8c.html#ac2a7192638c40706831495cb42ee4e96">More...</a><br /></td></tr>
<tr class="separator:ac2a7192638c40706831495cb42ee4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">sys_mutex_lock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for locking mutex (1) check if mutex is valid (2) check main and idle thread (3) check prio (4) check repeat lock  <a href="syscall__thread_8c.html#a6a14ccbc1e43d61617b97ecd06cf65b9">More...</a><br /></td></tr>
<tr class="separator:a6a14ccbc1e43d61617b97ecd06cf65b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">sys_mutex_unlock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for unlocking mutex (1) check if mutex exists (2) check if this mutex belong to current thread  <a href="syscall__thread_8c.html#a55db4294dd5ed35ee5b2b1b1043ddbdd">More...</a><br /></td></tr>
<tr class="separator:a55db4294dd5ed35ee5b2b1b1043ddbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c4d1eb39e9f8e33246ae15fdc53ef1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ac1c4d1eb39e9f8e33246ae15fdc53ef1">check_curr_PCP_NULL</a> (<a class="el" href="structTCB.html">TCB</a> *tcb, uint32_t index)</td></tr>
<tr class="memdesc:ac1c4d1eb39e9f8e33246ae15fdc53ef1"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for check current PCP  <a href="syscall__thread_8c.html#ac1c4d1eb39e9f8e33246ae15fdc53ef1">More...</a><br /></td></tr>
<tr class="separator:ac1c4d1eb39e9f8e33246ae15fdc53ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93332dd1367ee63de93825fb26bfa2f4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a93332dd1367ee63de93825fb26bfa2f4">check_Prio_Ceil</a> (<a class="el" href="structTCB.html">TCB</a> *tcb, uint32_t index)</td></tr>
<tr class="memdesc:a93332dd1367ee63de93825fb26bfa2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">function for check prio ceil  <a href="syscall__thread_8c.html#a93332dd1367ee63de93825fb26bfa2f4">More...</a><br /></td></tr>
<tr class="separator:a93332dd1367ee63de93825fb26bfa2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8435ca6bfee7bbc76ab6c14303d81179"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a8435ca6bfee7bbc76ab6c14303d81179">check_valid</a> (uint32_t curr)</td></tr>
<tr class="memdesc:a8435ca6bfee7bbc76ab6c14303d81179"><td class="mdescLeft">&#160;</td><td class="mdescRight">check valid condition  <a href="syscall__thread_8c.html#a8435ca6bfee7bbc76ab6c14303d81179">More...</a><br /></td></tr>
<tr class="separator:a8435ca6bfee7bbc76ab6c14303d81179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfa203f80109e0dd2e198fa572befd5a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#acfa203f80109e0dd2e198fa572befd5a">RMS_PCP_Scheduler</a> ()</td></tr>
<tr class="memdesc:acfa203f80109e0dd2e198fa572befd5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">RMS scheduler with PCP.  <a href="syscall__thread_8c.html#acfa203f80109e0dd2e198fa572befd5a">More...</a><br /></td></tr>
<tr class="separator:acfa203f80109e0dd2e198fa572befd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224842cc025bddd4be64826e9b06892d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a224842cc025bddd4be64826e9b06892d">pcp_check_block</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:a224842cc025bddd4be64826e9b06892d"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check mutex block for pcp  <a href="syscall__thread_8c.html#a224842cc025bddd4be64826e9b06892d">More...</a><br /></td></tr>
<tr class="separator:a224842cc025bddd4be64826e9b06892d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ecf28941315b1509ab3cf9fa0944d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ab0ecf28941315b1509ab3cf9fa0944d7">pcp_check_unblock</a> (<a class="el" href="structkmutex__t.html">kmutex_t</a> *<a class="el" href="structmutex.html">mutex</a>)</td></tr>
<tr class="memdesc:ab0ecf28941315b1509ab3cf9fa0944d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">function to check mutex unblock for pcp  <a href="syscall__thread_8c.html#ab0ecf28941315b1509ab3cf9fa0944d7">More...</a><br /></td></tr>
<tr class="separator:ab0ecf28941315b1509ab3cf9fa0944d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6bb8358f10f6635f0984cc93fc6eb689"><td class="memItemLeft" align="right" valign="top"><a id="a6bb8358f10f6635f0984cc93fc6eb689"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a6bb8358f10f6635f0984cc93fc6eb689">__thread_u_stacks_limit</a></td></tr>
<tr class="memdesc:a6bb8358f10f6635f0984cc93fc6eb689"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread user stack region limits <br /></td></tr>
<tr class="separator:a6bb8358f10f6635f0984cc93fc6eb689"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a198c2b50754889188a7a086eb019fd9c"><td class="memItemLeft" align="right" valign="top"><a id="a198c2b50754889188a7a086eb019fd9c"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a198c2b50754889188a7a086eb019fd9c">__thread_k_stacks_limit</a></td></tr>
<tr class="memdesc:a198c2b50754889188a7a086eb019fd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread kernel stack region limits <br /></td></tr>
<tr class="separator:a198c2b50754889188a7a086eb019fd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70f4a39c2ccb2efc0b006dff5048fbd"><td class="memItemLeft" align="right" valign="top"><a id="ad70f4a39c2ccb2efc0b006dff5048fbd"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#ad70f4a39c2ccb2efc0b006dff5048fbd">__thread_u_stacks_base</a></td></tr>
<tr class="memdesc:ad70f4a39c2ccb2efc0b006dff5048fbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread user stack region base <br /></td></tr>
<tr class="separator:ad70f4a39c2ccb2efc0b006dff5048fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fda98b0ffb93f4efebe0d52c9e300fa"><td class="memItemLeft" align="right" valign="top"><a id="a0fda98b0ffb93f4efebe0d52c9e300fa"></a>
char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a0fda98b0ffb93f4efebe0d52c9e300fa">__thread_k_stacks_base</a></td></tr>
<tr class="memdesc:a0fda98b0ffb93f4efebe0d52c9e300fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">thread kernel stack region base <br /></td></tr>
<tr class="separator:a0fda98b0ffb93f4efebe0d52c9e300fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">ub_table</a> []</td></tr>
<tr class="memdesc:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="mdescLeft">&#160;</td><td class="mdescRight">precomputed values for UB test  <a href="syscall__thread_8c.html#a187e79dd2a6a18d6bbbc4f2509eb668b">More...</a><br /></td></tr>
<tr class="separator:a187e79dd2a6a18d6bbbc4f2509eb668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a18d0f0ce2251a286b13152afa9f4f5"><td class="memItemLeft" align="right" valign="top"><a id="a9a18d0f0ce2251a286b13152afa9f4f5"></a>
<a class="el" href="structTCB.html">TCB</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a9a18d0f0ce2251a286b13152afa9f4f5">TCB_array</a> [16]</td></tr>
<tr class="memdesc:a9a18d0f0ce2251a286b13152afa9f4f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">define global <a class="el" href="structTCB.html" title="define structure for TCB">TCB</a> array <br /></td></tr>
<tr class="separator:a9a18d0f0ce2251a286b13152afa9f4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0f3d32b9f363c6a0d820e2eff0e51e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structkernel__struct.html">kernel_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#af0f3d32b9f363c6a0d820e2eff0e51e9">global_stack</a></td></tr>
<tr class="memdesc:af0f3d32b9f363c6a0d820e2eff0e51e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">define global stack variable to use  <a href="syscall__thread_8c.html#af0f3d32b9f363c6a0d820e2eff0e51e9">More...</a><br /></td></tr>
<tr class="separator:af0f3d32b9f363c6a0d820e2eff0e51e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f226684a28b936b5b867102a5fb0eb8"><td class="memItemLeft" align="right" valign="top"><a id="a4f226684a28b936b5b867102a5fb0eb8"></a>
<a class="el" href="structkmutex__t.html">kmutex_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a4f226684a28b936b5b867102a5fb0eb8">global_mutexes</a> [32]</td></tr>
<tr class="memdesc:a4f226684a28b936b5b867102a5fb0eb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">define struct for mutex <br /></td></tr>
<tr class="separator:a4f226684a28b936b5b867102a5fb0eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a260e06ce96c2e4deebccaedeb059dc0b"><td class="memItemLeft" align="right" valign="top"><a id="a260e06ce96c2e4deebccaedeb059dc0b"></a>
uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="syscall__thread_8c.html#a260e06ce96c2e4deebccaedeb059dc0b">tick</a> = 0</td></tr>
<tr class="memdesc:a260e06ce96c2e4deebccaedeb059dc0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">define systick time <br /></td></tr>
<tr class="separator:a260e06ce96c2e4deebccaedeb059dc0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>thread syscall implementation for lab 4 </p>
<dl class="section note"><dt>Note</dt><dd>Not for public release, do not share</dd></dl>
<dl class="section date"><dt>Date</dt><dd>last modified 14 October 2022 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>CMU 14-642 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9b1cf2fc01bb33b62a5d3a1acbe851e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1cf2fc01bb33b62a5d3a1acbe851e8">&#9670;&nbsp;</a></span>calculate_utilization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float calculate_utilization </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>calculate utilization for UB test </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">C</td><td>execution time (scheduler ticks) </td></tr>
    <tr><td class="paramname">T</td><td>task period (scheduler ticks) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>float, return calculated utilization </dd></dl>

</div>
</div>
<a id="ac1c4d1eb39e9f8e33246ae15fdc53ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c4d1eb39e9f8e33246ae15fdc53ef1">&#9670;&nbsp;</a></span>check_curr_PCP_NULL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_curr_PCP_NULL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTCB.html">TCB</a> *&#160;</td>
          <td class="paramname"><em>tcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for check current PCP </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcb</td><td>tcb structure to be checked </td></tr>
    <tr><td class="paramname">index</td><td>thread index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread index </dd></dl>

</div>
</div>
<a id="ac2a7192638c40706831495cb42ee4e96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2a7192638c40706831495cb42ee4e96">&#9670;&nbsp;</a></span>check_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_handle </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mutex_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if mutex exists </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex_index</td><td>mutex_index to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>return 0 if exists; return 1 if not exists </dd></dl>

</div>
</div>
<a id="a93332dd1367ee63de93825fb26bfa2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93332dd1367ee63de93825fb26bfa2f4">&#9670;&nbsp;</a></span>check_Prio_Ceil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_Prio_Ceil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structTCB.html">TCB</a> *&#160;</td>
          <td class="paramname"><em>tcb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for check prio ceil </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tcb</td><td>tcb structure to be checked </td></tr>
    <tr><td class="paramname">index</td><td>thread index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>thread index </dd></dl>

</div>
</div>
<a id="a8435ca6bfee7bbc76ab6c14303d81179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8435ca6bfee7bbc76ab6c14303d81179">&#9670;&nbsp;</a></span>check_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t check_valid </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>curr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check valid condition </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">curr</td><td>current thread index </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true or false </dd></dl>

</div>
</div>
<a id="a9b7723d9d93291270e4ca71289e8a3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7723d9d93291270e4ca71289e8a3c4">&#9670;&nbsp;</a></span>mutex_check_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_check_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check if mutex is locked by specific thread </p>
<p>function for locking mutex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ad4de7534d78e9925e4465a8de5fb7dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4de7534d78e9925e4465a8de5fb7dfb">&#9670;&nbsp;</a></span>mutex_check_unblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mutex_check_unblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>uunblock mutex, check next thread for this mutex </p>
<p>function for unlocking mutex</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be unblocked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a224842cc025bddd4be64826e9b06892d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224842cc025bddd4be64826e9b06892d">&#9670;&nbsp;</a></span>pcp_check_block()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcp_check_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to check mutex block for pcp </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ab0ecf28941315b1509ab3cf9fa0944d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ecf28941315b1509ab3cf9fa0944d7">&#9670;&nbsp;</a></span>pcp_check_unblock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void pcp_check_unblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function to check mutex unblock for pcp </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be checked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a3804439769e7e553283b916886c5b67d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3804439769e7e553283b916886c5b67d">&#9670;&nbsp;</a></span>pendsv_c_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* pendsv_c_handler </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>msp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>pendsv c handler function </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msp</td><td>msp register to get stack address for thread (1) call scheduler function to find next thread to be scheduled (2) set and get svc status (3) do context switch and return corresponding thread stack address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfa203f80109e0dd2e198fa572befd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfa203f80109e0dd2e198fa572befd5a">&#9670;&nbsp;</a></span>RMS_PCP_Scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RMS_PCP_Scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RMS scheduler with PCP. </p>
<dl class="section return"><dt>Returns</dt><dd>next thread to be scheduled </dd></dl>

</div>
</div>
<a id="a3595cc3f898a5bedef3510bf9dd8f6f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3595cc3f898a5bedef3510bf9dd8f6f1">&#9670;&nbsp;</a></span>RMS_Scheduler_Highest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t RMS_Scheduler_Highest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>RMS scheduler to find next thread to be scheduled. </p>
<dl class="section return"><dt>Returns</dt><dd>next scheduled thread </dd></dl>

</div>
</div>
<a id="aa2cee94a562548fe28ea76bd6ceb738c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cee94a562548fe28ea76bd6ceb738c">&#9670;&nbsp;</a></span>round_robin_scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t round_robin_scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>round robin scheduler to find next thread to be scheduled </p>
<p>round robin scheduler</p>
<dl class="section return"><dt>Returns</dt><dd>return next scheduled thread </dd></dl>

</div>
</div>
<a id="a0f015c606e6bf18b8a9311f70bb3dbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f015c606e6bf18b8a9311f70bb3dbc8">&#9670;&nbsp;</a></span>schedule_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t schedule_next </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>call corresponding scheduler function to find scheduled thread </p>
<p>find next thread to be scheduled</p>
<dl class="section return"><dt>Returns</dt><dd>next scheduled thread </dd></dl>

</div>
</div>
<a id="a8b4f86fe10ac2c90ce8158872aac7ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b4f86fe10ac2c90ce8158872aac7ce2">&#9670;&nbsp;</a></span>sys_get_priority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_priority </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get thread priority </p>
<p>get the dynamic priority of the running thread</p>
<dl class="section return"><dt>Returns</dt><dd>priority for current thread </dd></dl>

</div>
</div>
<a id="a341334c885696457b6f66bb8acda5b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a341334c885696457b6f66bb8acda5b22">&#9670;&nbsp;</a></span>sys_get_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_get_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get global time, update time field in every systick </p>
<p>get the current time in ticks</p>
<dl class="section return"><dt>Returns</dt><dd>global time when function is called </dd></dl>

</div>
</div>
<a id="a12d3058e8c4464d614c9506562710e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12d3058e8c4464d614c9506562710e91">&#9670;&nbsp;</a></span>sys_mutex_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkmutex__t.html">kmutex_t</a>* sys_mutex_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_prio</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for initializing mutex </p>
<p>Used to create a mutex object. The mutex resides in kernel space. The user receives a handle to it. With memory protection, the user cannot modify it. However, tt can still be passed around and used with lock, unlock.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_prio</td><td>update prio_ceil for mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>initialized mutex structure </dd></dl>

</div>
</div>
<a id="a6a14ccbc1e43d61617b97ecd06cf65b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a14ccbc1e43d61617b97ecd06cf65b9">&#9670;&nbsp;</a></span>sys_mutex_lock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for locking mutex (1) check if mutex is valid (2) check main and idle thread (3) check prio (4) check repeat lock </p>
<p>Lock a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be locked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a55db4294dd5ed35ee5b2b1b1043ddbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55db4294dd5ed35ee5b2b1b1043ddbdd">&#9670;&nbsp;</a></span>sys_mutex_unlock()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structkmutex__t.html">kmutex_t</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for unlocking mutex (1) check if mutex exists (2) check if this mutex belong to current thread </p>
<p>Unlock a mutex.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mutex</td><td>mutex to be unlocked </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="a0726d2166701a485c555e6b7f7af3b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0726d2166701a485c555e6b7f7af3b60">&#9670;&nbsp;</a></span>sys_scheduler_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_scheduler_start </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>frequency</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>function for starting scheduler, start systick and call pendsv interrupt </p>
<p>tell the kernel to start running threads using Systick</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">frequency</td><td>freq for systick interrupt </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if successful, return 0; else return -1 </dd></dl>

</div>
</div>
<a id="ac54104218aaaba481bd42968a6045691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54104218aaaba481bd42968a6045691">&#9670;&nbsp;</a></span>sys_thread_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_create </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>prio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>vargp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create thread using provided parameters </p>
<p>create a new thread as specified, if UB allows</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fn</td><td>function to be called, stored in pc register </td></tr>
    <tr><td class="paramname">prio</td><td>priority for created thread </td></tr>
    <tr><td class="paramname">C</td><td>execution time (scheduler ticks) </td></tr>
    <tr><td class="paramname">T</td><td>task period (scheduler ticks) </td></tr>
    <tr><td class="paramname">vargp</td><td>parameter for function, stored in ro register </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if successful, return 0; else return -1 </dd></dl>

</div>
</div>
<a id="a3b452cd176c28323372e441a3aac0631"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b452cd176c28323372e441a3aac0631">&#9670;&nbsp;</a></span>sys_thread_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sys_thread_init </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>stack_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>idle_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu_8h.html#a9981a4d7a6ee4804657e50e0741eb78b">mpu_mode</a>&#160;</td>
          <td class="paramname"><em>memory_protection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_mutexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>init thread function </p>
<p>initialize thread switching</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_threads</td><td>max number of thread to be initialized </td></tr>
    <tr><td class="paramname">stack_size</td><td>stack size for each thread </td></tr>
    <tr><td class="paramname">idle_fn</td><td>idle function </td></tr>
    <tr><td class="paramname">memory_protection</td><td>specify memory protection type </td></tr>
    <tr><td class="paramname">max_mutexes</td><td>max mutexes to be used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>if successful, return 0; if not, return -1 </dd></dl>

</div>
</div>
<a id="a601e5d8e922ccdec535527e8d8724d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601e5d8e922ccdec535527e8d8724d78">&#9670;&nbsp;</a></span>sys_thread_kill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_thread_kill </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>thread kill function (1) kill current thread, update status (2) update utilization field for thread reuse </p>
<p>kill the running thread</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="aa8933e910725546aa9e052369db9cf81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8933e910725546aa9e052369db9cf81">&#9670;&nbsp;</a></span>sys_thread_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t sys_thread_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get thread time </p>
<p>get the total elapsed time for the running thread</p>
<dl class="section return"><dt>Returns</dt><dd>thread time when function is called </dd></dl>

</div>
</div>
<a id="a2a3a3fb472158a93e59df836b9935b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3a3fb472158a93e59df836b9935b54">&#9670;&nbsp;</a></span>sys_wait_until_next_period()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void sys_wait_until_next_period </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>syscall for wait until next period function (1) update current thread's status to waiting status (2) call pendsv to do context switch </p>
<p>deschedule thread and wait until next turn</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<a id="ae24f0f7bfbc5f3ebc4100c56a6f96490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24f0f7bfbc5f3ebc4100c56a6f96490">&#9670;&nbsp;</a></span>Systick_RMS_scheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Systick_RMS_scheduler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>update RMS status for every systick </p>
<p>function for update status everytime systick is called</p>
<dl class="section return"><dt>Returns</dt><dd>None </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="af0f3d32b9f363c6a0d820e2eff0e51e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0f3d32b9f363c6a0d820e2eff0e51e9">&#9670;&nbsp;</a></span>global_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structkernel__struct.html">kernel_struct</a> global_stack</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>define global stack variable to use </p>
<p>define global_stack to access global variable </p>

</div>
</div>
<a id="a187e79dd2a6a18d6bbbc4f2509eb668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187e79dd2a6a18d6bbbc4f2509eb668b">&#9670;&nbsp;</a></span>ub_table</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float ub_table[]</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    0.000, 1.000, .8284, .7798, .7568,</div>
<div class="line">     .7435, .7348, .7286, .7241, .7205,</div>
<div class="line">     .7177, .7155, .7136, .7119, .7106,</div>
<div class="line">     .7094, .7083, .7075, .7066, .7059,</div>
<div class="line">     .7052, .7047, .7042, .7037, .7033,</div>
<div class="line">     .7028, .7025, .7021, .7018, .7015,</div>
<div class="line">     .7012, .7009</div>
<div class="line">}</div>
</div><!-- fragment -->
<p>precomputed values for UB test </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
</div>
<hr class="footer"/><address class="footer"><small>
Generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>